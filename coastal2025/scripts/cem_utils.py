import sys
sys.path.append('../scripts')  # Path relative to the notebook
import buoypy as bp
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import ArtistAnimation
from matplotlib import path
from scipy import stats, signal
from scipy.spatial import cKDTree
from IPython.display import clear_output
from mpl_toolkits.axes_grid1 import make_axes_locatable

def compute_wave_parameters(station,year_range,shore_rotation_deg_CC):

    ''' This function computes time averaged wave parameters including 
    A (asymmetry index), U (fraction approaching from unstable angles),
    Hs (mean significant wave height), Dir (mean wave direction), and 
    Tp (mean wave period). Inputs include a station number (int), a year
    range (2 value tuple) and shoreline rotation angle in degrees, oriented
    counter clockwise'''
    
    # get wave data from buoy station
    year = np.NAN
    H = bp.historic_data(station,year,year_range)
    X = H.get_all_stand_meteo()

    # get rid of missing data
    X.mask((X==99.0) | (X==9999.0), inplace=True)

    Hs = np.mean(X.WVHT)
    Tp = np.mean(X.DPD)
    [Dir,count] = stats.mode(X.MWD, keepdims=False, nan_policy='omit') 
    
    # Sort data into 4 directional bins a la Ashton et al. 
    #convert the wave direction data to numpy array and drop NaN values 
    rawdirs = X.MWD.dropna().to_numpy()

    #reorient the raw wave direction data to be relative to shore normal
    shore_normal_dirs = rawdirs+shore_rotation_deg_CC
    shore_normal_dirs[shore_normal_dirs>360] = shore_normal_dirs[shore_normal_dirs>360] - 360

    #remove bad directional data 
    bad_dir_inds = np.where((shore_normal_dirs > 90) & (shore_normal_dirs < 270))
    bad_dir_inds = bad_dir_inds[0]
    shore_normal_dirs = np.delete(shore_normal_dirs,bad_dir_inds)
    # print(shore_normal_dirs.size)

    #compute the fraction of waves that approach from unstable angles
    unstable_inds = np.where((shore_normal_dirs <= 315) & (shore_normal_dirs >= 30))
    unstable_inds = unstable_inds[0]
    U = unstable_inds.size / shore_normal_dirs.size

    #compute the asymmetry index
    left_wave_inds = np.where(shore_normal_dirs<=180)
    left_wave_inds = left_wave_inds[0]
    A = left_wave_inds.size / shore_normal_dirs.size

    plt.hist(shore_normal_dirs, bins=[0, 45, 90, 270, 315, 360])
    
    return Hs,Tp,Dir,A,U

def plotmeteo(X):
    fig, axes = plt.subplots(2, sharex=True);
    axes[0].plot(X.index,X.WVHT)
    axes[1].plot(X.index,X.DPD)
    axes[0].set_ylabel('Wave Height (m)', fontsize=12);
    axes[1].set_ylabel('Dominant Period (s)', fontsize=12);
    axes[1].set_xlabel('');

def rotate_shoreline(x,y,angle='auto'):
    '''This function takes points (x,y) and rotates them by an angle
    The angle is automatically generated by the end points of the shorelines coordinates
    If this approach doesnt work for some reason you may input an angle maually (in degrees).'''
    
    if angle == 'auto':
        sign = -1 if y[-1]>y[0] else 1
        a = sign*np.arctan((y[-1]-y[0])/(x[-1]-x[0]))
    else:
        a = angle*np.pi/180
    # using this roation matix
    xnew = (x ) * np.cos(a) - (y ) * np.sin(a)  
    ynew = (x ) * np.sin(a) + (y ) * np.cos(a) 
    return xnew,ynew,np.degrees(a)

def fill_gaps(x, y, max_gap):
    x = np.array(x)
    y = np.array(y)
    
    x_filled = []
    y_filled = []

    for i in range(len(x) - 1):
        # Always include the current point
        x_filled.append(x[i])
        y_filled.append(y[i])

        # Compute the gap
        gap = x[i+1] - x[i]

        if gap > max_gap:
            # Number of new points to insert
            num_new = int(np.floor(gap / max_gap))

            # Generate new x values
            new_x = np.linspace(x[i], x[i+1], num=num_new+2)[1:-1]
            new_y = np.linspace(y[i], y[i+1], num=num_new+2)[1:-1]

            x_filled.extend(new_x)
            y_filled.extend(new_y)

    # Don't forget the last point
    x_filled.append(x[-1])
    y_filled.append(y[-1])

    return np.array(x_filled), np.array(y_filled)

# def shoreline_to_grid(x, y, dx, dy, plotdata=True):
#     """ function to convert xy shoreline to gridded elevation for input to CEM
#         takes arrays of x and y in UTM or lat lon values. Assumes a Dean Profile.
#         Will plot output unless specified plotdata=False
#             """
#     ##### build grid
#     # find the smallest and largest x's and y's to initialize grid boundaries
#     x0 = int(np.ceil(min(x) / dx) * dx) # lower left x values, rounded to 100
#     y0 = int(np.ceil(min(y) / dy) * dy)
#     x1 = x0 + int(np.ceil((max(x) - min(x)) / dx) * dx - 2 * dx)  # add total length of x to origin x
#     y1 = y0 + int(np.ceil((max(y) - min(y)) / dy) * dy + 5000)
#     # create mesh grid of x and y
#     # [xg, yg] = np.meshgrid(list(range(x0, x1, dx)), list(range(y0-2000, y1, dy)), sparse=False, indexing='ij')
#     # [xg, yg] = np.meshgrid(np.linspace(x0, x1, dx), np.linspace(y0-2000, y1, dy), sparse=False, indexing='ij')
#     [xg, yg] = np.meshgrid(
#         list(range(x0, x1, dx)),
#         list(range(y0-2000, y1, dy)),
#         sparse=False,
#         indexing='ij'
#     )

#     return xg, yg

# def create_dean_bathy(x,y,xg,yg,pad,A=0.1,b=(2/3),beachelev=1):
#     # Flatten grid points
#     grid_points = np.column_stack((xg.ravel(), yg.ravel()))
#     # Build KDTree from shoreline
#     shoreline_points = np.column_stack((x, y)) #reshape x,y to handshake with cKDTree class
#     tree = cKDTree(shoreline_points) #instantiate
#     # Query the nearest shoreline point for each grid cell
#     dist, _ = tree.query(grid_points) #use the query method in the cKDTree class
#     # Reshape distances back to grid shape
#     dist_map = dist.reshape(xg.shape)
#     # Allocate storage for z array
#     zg = np.zeros_like(xg)
#     # Compute dean profile
#     zg = A * dist_map ** b
#     # Set the beach elevation
#     # # smooth out to create gradient
#     neighs = np.ones([10,10])
#     total = (10**2)
#     zg = signal.convolve2d(zg,neighs/total,mode='same',boundary='symm')

#     for i in range(zg.shape[0]): #for all columns i
#         # find max row index where dist_map==0
#         j = np.argmin(dist_map[i, :])
#         zg[i, 0:j]= -beachelev
#     # Output the new bathymetry
#     zg=-zg.T.copy()
#     return zg, dist_map

def plot_coast(domain,dx,dy,fig=None,ax=None):
    '''Plot the coastline.
    
    Inputs:
    ------
    domain = any 2D array (though colorbar label is specific for water depth)
    
    '''
    N,M = domain.shape
    s = M/N
    if fig==None:
        fig,ax = plt.subplots(figsize=(int(s*8),7))
    im = ax.imshow(domain, origin='lower', cmap='viridis')
    
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    cb = fig.colorbar(im,cax=cax)
    cb.ax.tick_params('both',labelsize=15)
    cb.ax.set_ylabel('Water Depth (m)',fontsize=18,rotation=-90, labelpad=30)
    y = np.linspace(0,N,4)
    x = np.linspace(0,M,4)
    Y = (y*dy/(1000)).astype('int')
    X = np.asarray(x*dx/(1000)).astype('int')
    ax.set_yticks(y)
    ax.set_xticks(x)
    ax.set_yticklabels(Y)
    ax.set_xticklabels(X)
    ax.set_xlabel('Along shore (km)',fontsize=20)
    ax.set_ylabel('Cross shore (km)',fontsize=20)
    ax.tick_params('both',labelsize=15)
    return im

# def find_shelf_slope(domain, dx, pad=20): #same pad as above
#     h = lambda x: 0.1*x**(2/3) ## depth equation
#     profile = np.copy(domain)[:,0] ## find a nice straight column in the domain...
#     ## whose depth gradient is towards the top of the domain
#     x = np.arange(len(profile))*dx ## the off shore coords in [meters]
#     ## find the shoreline edge and approximate the gradient using the equation from the previous notebook:
#     x0 = x[pad] ## edge of beach--defined by the pad from previous step if that was used
#     xf = x[-1] ## open ocean depth
#     return (h(xf)-h(x0))/(xf-x0)

def initialize_models(params,domain,cem,waves,set_land):
    '''
    Inputs:
    ------
    
    -params = parameter dictionary
    
    -domain = initial elevation domain
        ---> domain values in (-inifinity,1] 
                -->> 1 = land, <1 = water
                
    -cem,waves = the imported models 
        --->ex: cem = pymt.Cem()
            
    '''
    p = params
    
    N,M = domain.shape

    args = cem.setup( number_of_rows = N , number_of_cols = M, 
                  grid_spacing = p['grid_spacing'] ,  shelf_slope = p['shelf_slope'] , 
                  shoreface_depth = p['shoreface_depth'] , shoreface_slope = p['shoreface_slope']
                )

    waves.initialize(*waves.setup())
    cem.initialize(*args)
    
    waves.set_value('sea_surface_water_wave__height', p['wave_height']);
    waves.set_value('sea_surface_water_wave__period',p['wave_period']);
    waves.set_value('sea_shoreline_wave~incoming~deepwater__ashton_et_al_approach_angle_highness_parameter',
                   p['wave_angle_highness']);
    waves.set_value('sea_shoreline_wave~incoming~deepwater__ashton_et_al_approach_angle_asymmetry_parameter',
                   p['wave_angle_asymmetry']);

    if set_land==True: #if need set land elevation; 'False' used default
        cem.set_value('land_surface__elevation',domain.flatten());
    cem.set_value('model__time_step', float(p['model__time_step']));

def run_model_loop(time_years, domain ,cem ,waves, qs_3,animate,update_ani_years):
    '''Loop to run the cem-waves models.
    This loop only couples the wave angles and will need to be changed to add additional coupling.
    It also assumes static variables such as sediment input and would need modification to update such variables.
    
    Inputs:
    ------
    
    -time_years = time you want to run the model in years
    
    -domain = initial elevation domain
        ---> domain values in (-inifinity,1] 
                -->> 1 = land, <1 = water
                
    -cem,waves = the imported models 
        --->ex: cem = pymt.Cem()
        
    '''

    alpha = 'sea_surface_water_wave__azimuth_angle_of_opposite_of_phase_velocity'
    update_ani = int(365*update_ani_years/cem.get_value('model__time_step'))
    T = int(365*time_years/cem.get_value('model__time_step'))
    dx,dy = cem.grid_spacing(cem.var_grid('sea_water__depth'))
    for time in range(T):
        waves.update()
        angle = waves.get_value(alpha)
        cem.set_value(alpha, angle)
        cem.set_value("land_surface_water_sediment~bedload__mass_flow_rate", np.array(qs_3[:,:,time]))
        cem.update()
        if animate:
            if time%update_ani == 0 or time==T-1:
                clear_output(wait=True)
                plot_coast(cem.get_value('land_surface__elevation').reshape(domain.shape),dx,dy)
                plt.title('Time : '+ str(round((time*cem.get_value('model__time_step')/365)[0],1)) +' years',fontsize=20)
                plt.show()

        else:
            clear_output(wait=True)
            print('Time Step: ',time, ' days')

def extract_raster_shoreline(land):
    gradx, grady = np.gradient(land)
    G = np.sqrt(gradx**2 + grady**2)

    # Binary mask for land
    landbin = np.zeros_like(land)
    landbin[land > 0] = 1

    # Newline where gradient > 0 and landbin == 1
    shoreline_map = np.zeros_like(land)
    shoreline_map[(G > 0) & (landbin == 1)] = 1
    return shoreline_map

def extract_vector_shoreline(land,window=1):
    gradx, grady = np.gradient(land)
    G = np.sqrt(gradx**2 + grady**2)

    # Binary mask for land
    landbin = np.zeros_like(land)
    landbin[land > 0] = 1

    # Newline where gradient > 0 and landbin == 1
    shoreline_map = np.zeros_like(land)
    shoreline_map[(G > 0) & (landbin == 1)] = 1

    xinds,yinds = np.where(shoreline_map==1)

    yinds,xinds = np.nonzero(shoreline_map)
    shoreline_x = xg[xinds,yinds]
    shoreline_y = yg[xinds,yinds]

    # Stack and sort by y (column), then x (row)
    sorted_indices = np.lexsort((shoreline_y, shoreline_x))

    # Apply the sorted order
    x_sorted = shoreline_x[sorted_indices]
    y_sorted = shoreline_y[sorted_indices]

    # Spline fit (not working right now?)
    # from scipy.interpolate import UnivariateSpline
    # spline = UnivariateSpline(x_sorted, y_sorted, s=window)  # `s` is the smoothing factor
    # y_smooth = spline(x_sorted)
    
    return x_sorted,y_sorted

def vid_model_loop(time_years, domain ,cem ,waves, qs_3,animate,update_ani_years):
    '''Loop to run the cem-waves models.
    This loop only couples the wave angles and will need to be changed to add additional coupling.
    It also assumes static variables such as sediment input and would need modification to update such variables.
    Inputs:
    ------
    -time_years = time you want to run the model in years
    -domain = initial elevation domain
        ---> domain values in (-inifinity,1]
                -->> 1 = land, <1 = water
    -cem,waves = the imported models
        --->ex: cem = pymt.Cem()
    '''
    alpha = 'sea_surface_water_wave__azimuth_angle_of_opposite_of_phase_velocity'
    update_ani = int(365*update_ani_years/cem.get_value('model__time_step'))
    T = int(365*time_years/cem.get_value('model__time_step'))
    dx,dy = cem.grid_spacing(cem.var_grid('sea_water__depth'))
    i=0
    ims = []
    N,M = domain.shape
    s = M/N
    fig,ax = plt.subplots(figsize=(int(s*3),5))
    for time in range(T):
        waves.update()
        angle = waves.get_value(alpha)
        cem.set_value(alpha, angle)
        cem.set_value("land_surface_water_sediment~bedload__mass_flow_rate", np.array(qs_3[:,:,time]))
        cem.update()
        if animate:
            if time%update_ani == 0 or time==T-1:
                i+=1
                clear_output(wait=True)
                im = plot_coast(cem.get_value('land_surface__elevation').reshape(domain.shape),dx,dy,fig,ax)
                ttl = plt.title('Time : '+ str(round((time*cem.get_value('model__time_step')/365)[0],1)) +' yrs',fontsize=20)
                #plt.savefig(png_dir + str((round((time*cem.get_value('model__time_step')/365)[0],1))/1000) + '.png') #turn on when creating animation gif
                ims.append([im,ttl])
        else:
            clear_output(wait=True)
            print('Time Step: ',time, ' days')
    anim = ArtistAnimation(fig, ims, interval=500, blit=True, repeat_delay=2000)
    return anim


##############################################
# Old group's shoreline to CEM domain functions

def plotcoast(domain,dx,dy):
    '''Plot the coastline.
    
    Inputs:
    ------
    domain = any 2D array (though colorbar label is specific for water depth)
    
    '''
    N,M = domain.shape
    s = M/N
    fig,ax = plt.subplots(figsize=(int(s*8),7))
    im = ax.imshow(domain, origin='lower', cmap='viridis')
    
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    cb = fig.colorbar(im,cax=cax)
    cb.ax.tick_params('both',labelsize=15)
    cb.ax.set_ylabel('Water Depth (m)',fontsize=20,rotation=-90, labelpad=30)
    y = np.linspace(0,N,4)
    x = np.linspace(0,M,4)
    Y = (y*dy/(1000)).astype('int')
    X = np.asarray(x*dx/(1000)).astype('int')
    ax.set_yticks(y)
    ax.set_xticks(x)
    ax.set_yticklabels(Y)
    ax.set_xticklabels(X)
    ax.set_xlabel('Along shore (km)',fontsize=20)
    ax.set_ylabel('Cross shore (km)',fontsize=20)
    ax.tick_params('both',labelsize=15)

def set_domain(elev, pad=20):
    z_elev = elev.T.copy() # transpose of the elevations for CEM/plotting purposes
    z_elev[z_elev==-5] = -1 ## -5 is the "shoreline" flag from above.
    domain = -1*z_elev ## we want the domain to have values above sea-level to be >0 and below <0

    # neighs = np.ones([10,10])
    # total = (10**2)
    # domain = signal.convolve2d(domain,neighs/total,mode='same',boundary='symm')

    # domain[z_elev==-1] = 5 ## our shoreline got smoothed out too. This fixes that and makes sure our land is at 1m above sea level

    mat = []
    N,M = domain.shape
    for i in range(0,N):
        for j in range(0,M):
            if domain[i,j] > -1.1:
                mat.append([i,j])
    matrix = np.zeros((len(mat),2))
    for i in range(0,len(mat)):
        matrix[i,0] = mat[i][0]
        matrix[i,1] = mat[i][1]
    sortedm = matrix[matrix[:, 1].argsort()]
    Nval = sortedm[:,0]
    Mval = sortedm[:,1]
    nrow=[]
    for n in Nval:
        nrow.append(int(n))
    mcol=[]
    for m in Mval:
        mcol.append(int(m))
       
    for n in range(0,len(nrow)):
        for Nn in range(0,N):
            if Nn<nrow[n]:
                domain[Nn,mcol[n]]= 1

    N,M = domain.shape
    domnew = np.ones([N+pad,M])*1 ##here we add a "pad" to the bottom of the domain
    domnew[-N:,:] = domain # if this is undesirable, set "pad=0"
    domain = domnew


    return(domain)

def find_shelf_slope(domain, dx, pad=20): #same pad as above
    h = lambda x: 0.1*x**(2/3) ## depth equation
    profile = np.copy(domain)[:,0] ## find a nice straight column in the domain...
    ## whose depth gradient is towards the top of the domain
    x = np.arange(len(profile))*dx ## the off shore coords in [meters]
    ## find the shoreline edge and approximate the gradient using the equation from the previous notebook:
    x0 = x[pad] ## edge of beach--defined by the pad from previous step if that was used
    xf = x[-1] ## open ocean depth
    return (h(xf)-h(x0))/(xf-x0) 

def shorelinetogrid(x, y, dx, dy, plotdata=True):
    """ function to convert xy shoreline to gridded elevation for input to CEM
        takes arrays of x and y in UTM or lat lon values. Assumes a Dean Profile.
        Will plot output unless specified plotdata=False
            """
    # build grid
    # find the smallest and largest x's and y's to initialize grid boundaries
    x0 = int(np.ceil(min(x) / dx) * dx)
    y0 = int(np.ceil(min(y) / dy) * dy)
    x1 = x0 + int(np.ceil((max(x) - min(x)) / dx) * dx - 2 * dx)  # add total length of x to origin x
    y1 = y0 + int(np.ceil((max(y) - min(y)) / dy) * dy + 5000)

    # create mesh grid of x and y
    [xg, yg] = np.meshgrid(list(range(x0, x1, dx)), list(range(y0, y1, dy)), sparse=False, indexing='ij')

    # generate bathy using dean profile
    surf_width = 1000
    A = 0.1
    landmax = 1
    rng = 100000
    zg = np.zeros_like(xg)
    dist = np.zeros_like(xg)

    for i in range(0, xg.shape[1]):
        for j in range(0, xg.shape[0]):
            inrange = (abs(x - xg[j, i]) < rng) & (abs(y - yg[j, i]) < rng);
            r = np.zeros_like(x);
            r[inrange] = (x[inrange] - xg[j, i]) ** 2 + (y[inrange] - yg[j, i]) ** 2;
            r[~inrange] = 1.e10;
            # Compute closest grid cell
            value = min(r);
            dist[j, i] = np.sqrt(value);
            zg[j, i] = -A * (dist[j, i]) ** (2 / 3);

    p = path.Path(np.transpose([x, y]))
    IN = p.contains_points(np.transpose([xg.flatten(), yg.flatten()]))
    IN = IN.reshape(xg.shape)
    # zg[IN] = (min(A * (dist[IN]) ** (2 / 3))) + 1
    zg = zg * -1
    if plotdata == True:
        M,N = zg.shape
        s = M/N
        plt.figure(figsize=(int(s*8),7))
        Bathy = plt.contourf(xg, yg, zg, cmap=plt.cm.GnBu)
        cbar = plt.colorbar(Bathy)
        cbar.ax.set_ylabel('Water Depth (m)', fontsize=20, rotation=-90, labelpad=30)
        plt.xlabel('Eastings', fontsize=20)
        plt.ylabel('Northings', fontsize=20)
        plt.tick_params('both', labelsize=15)
        cbar.ax.tick_params('y', labelsize=15)
        Shore = plt.plot(x, y, 'k')
    return xg, yg, zg

